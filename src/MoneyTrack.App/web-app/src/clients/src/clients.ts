/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.12.1.0 (NJsonSchema v10.4.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IApiClient {
    /**
     * @return Success
     */
    apiV1ExpenceDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1ExpenceGet(id: number): Promise<SwaggerResponse<ExpenceResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ExpencePost(id: number, body?: ExpenceRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1ExpenceList(orderId: number): Promise<SwaggerResponse<ExpenceResponse[]>>;
    /**
     * @return Success
     */
    apiV1ExpencePlaceDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1ExpencePlaceGet(id: number): Promise<SwaggerResponse<ExpencePlaceResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ExpencePlacePost(id: number, body?: ExpencePlaceRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1ExpencePlaceList(): Promise<SwaggerResponse<ExpencePlaceResponse[]>>;
    /**
     * @return Success
     */
    apiV1OrderDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1OrderGet(id: number): Promise<SwaggerResponse<OrderResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1OrderPost(id: number, body?: OrderRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1OrderList(): Promise<SwaggerResponse<OrderResponse[]>>;
    /**
     * @return Success
     */
    apiV1ProductDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1ProductGet(id: number): Promise<SwaggerResponse<ProductResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ProductPost(id: number, body?: ProductRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1ProductList(): Promise<SwaggerResponse<ProductResponse[]>>;
    /**
     * @return Success
     */
    apiV1ProductTypeDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1ProductTypeGet(id: number): Promise<SwaggerResponse<ProductTypeResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ProductTypePost(id: number, body?: ProductTypeRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1ProductTypeList(): Promise<SwaggerResponse<ProductTypeResponse[]>>;
    /**
     * @return Success
     */
    apiV1UserDelete(id: number): Promise<SwaggerResponse<DeleteResponse>>;
    /**
     * @return Success
     */
    apiV1UserGet(id: number): Promise<SwaggerResponse<UserResponse>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1UserPost(id: number, body?: UserRequest | undefined): Promise<SwaggerResponse<SaveResponse>>;
    /**
     * @return Success
     */
    apiV1UserList(): Promise<SwaggerResponse<UserResponse[]>>;
    /**
     * @return Success
     */
    weatherforecast(): Promise<SwaggerResponse<WeatherForecast[]>>;
}

export class ApiClient implements IApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://host.docker.internal:2022";
    }

    /**
     * @return Success
     */
    apiV1ExpenceDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpenceDelete(_response);
        });
    }

    protected processApiV1ExpenceDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ExpenceGet(id: number): Promise<SwaggerResponse<ExpenceResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpenceGet(_response);
        });
    }

    protected processApiV1ExpenceGet(response: Response): Promise<SwaggerResponse<ExpenceResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenceResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ExpenceResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ExpencePost(id: number, body?: ExpenceRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpencePost(_response);
        });
    }

    protected processApiV1ExpencePost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ExpenceList(orderId: number): Promise<SwaggerResponse<ExpenceResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/Expence/list/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpenceList(_response);
        });
    }

    protected processApiV1ExpenceList(response: Response): Promise<SwaggerResponse<ExpenceResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpenceResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ExpenceResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ExpencePlaceDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/place/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpencePlaceDelete(_response);
        });
    }

    protected processApiV1ExpencePlaceDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ExpencePlaceGet(id: number): Promise<SwaggerResponse<ExpencePlaceResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/place/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpencePlaceGet(_response);
        });
    }

    protected processApiV1ExpencePlaceGet(response: Response): Promise<SwaggerResponse<ExpencePlaceResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpencePlaceResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ExpencePlaceResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ExpencePlacePost(id: number, body?: ExpencePlaceRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/Expence/place/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpencePlacePost(_response);
        });
    }

    protected processApiV1ExpencePlacePost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ExpencePlaceList(): Promise<SwaggerResponse<ExpencePlaceResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/Expence/place/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ExpencePlaceList(_response);
        });
    }

    protected processApiV1ExpencePlaceList(response: Response): Promise<SwaggerResponse<ExpencePlaceResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpencePlaceResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ExpencePlaceResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1OrderDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1OrderDelete(_response);
        });
    }

    protected processApiV1OrderDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1OrderGet(id: number): Promise<SwaggerResponse<OrderResponse>> {
        let url_ = this.baseUrl + "/api/v1/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1OrderGet(_response);
        });
    }

    protected processApiV1OrderGet(response: Response): Promise<SwaggerResponse<OrderResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<OrderResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1OrderPost(id: number, body?: OrderRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1OrderPost(_response);
        });
    }

    protected processApiV1OrderPost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1OrderList(): Promise<SwaggerResponse<OrderResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/Order/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1OrderList(_response);
        });
    }

    protected processApiV1OrderList(response: Response): Promise<SwaggerResponse<OrderResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<OrderResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductDelete(_response);
        });
    }

    protected processApiV1ProductDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductGet(id: number): Promise<SwaggerResponse<ProductResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductGet(_response);
        });
    }

    protected processApiV1ProductGet(response: Response): Promise<SwaggerResponse<ProductResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ProductResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ProductPost(id: number, body?: ProductRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductPost(_response);
        });
    }

    protected processApiV1ProductPost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductList(): Promise<SwaggerResponse<ProductResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/Product/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductList(_response);
        });
    }

    protected processApiV1ProductList(response: Response): Promise<SwaggerResponse<ProductResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ProductResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductTypeDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductTypeDelete(_response);
        });
    }

    protected processApiV1ProductTypeDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductTypeGet(id: number): Promise<SwaggerResponse<ProductTypeResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductTypeGet(_response);
        });
    }

    protected processApiV1ProductTypeGet(response: Response): Promise<SwaggerResponse<ProductTypeResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTypeResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ProductTypeResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1ProductTypePost(id: number, body?: ProductTypeRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/Product/type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductTypePost(_response);
        });
    }

    protected processApiV1ProductTypePost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1ProductTypeList(): Promise<SwaggerResponse<ProductTypeResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/Product/type/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1ProductTypeList(_response);
        });
    }

    protected processApiV1ProductTypeList(response: Response): Promise<SwaggerResponse<ProductTypeResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<ProductTypeResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1UserDelete(id: number): Promise<SwaggerResponse<DeleteResponse>> {
        let url_ = this.baseUrl + "/api/v1/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1UserDelete(_response);
        });
    }

    protected processApiV1UserDelete(response: Response): Promise<SwaggerResponse<DeleteResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<DeleteResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1UserGet(id: number): Promise<SwaggerResponse<UserResponse>> {
        let url_ = this.baseUrl + "/api/v1/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1UserGet(_response);
        });
    }

    protected processApiV1UserGet(response: Response): Promise<SwaggerResponse<UserResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<UserResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiV1UserPost(id: number, body?: UserRequest | undefined): Promise<SwaggerResponse<SaveResponse>> {
        let url_ = this.baseUrl + "/api/v1/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1UserPost(_response);
        });
    }

    protected processApiV1UserPost(response: Response): Promise<SwaggerResponse<SaveResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveResponse.fromJS(resultData200);
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SaveResponse.fromJS(resultData201);
            return new SwaggerResponse(status, _headers, result201);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<SaveResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    apiV1UserList(): Promise<SwaggerResponse<UserResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/User/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiV1UserList(_response);
        });
    }

    protected processApiV1UserList(response: Response): Promise<SwaggerResponse<UserResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<UserResponse[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @return Success
     */
    weatherforecast(): Promise<SwaggerResponse<WeatherForecast[]>> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeatherforecast(_response);
        });
    }

    protected processWeatherforecast(response: Response): Promise<SwaggerResponse<WeatherForecast[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return new SwaggerResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SwaggerResponse<WeatherForecast[]>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export class DeleteResponse implements IDeleteResponse {
    typeName?: string | undefined;
    id?: number;
    deleted?: boolean;

    constructor(data?: IDeleteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.id = _data["id"];
            this.deleted = _data["deleted"];
        }
    }

    static fromJS(data: any): DeleteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["id"] = this.id;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface IDeleteResponse {
    typeName?: string | undefined;
    id?: number;
    deleted?: boolean;
}

export class ErrorResponse implements IErrorResponse {
    primaryErrorCode?: string | undefined;
    errors?: string[] | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryErrorCode = _data["primaryErrorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryErrorCode"] = this.primaryErrorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IErrorResponse {
    primaryErrorCode?: string | undefined;
    errors?: string[] | undefined;
}

export class ExpencePlaceRequest implements IExpencePlaceRequest {
    name?: string | undefined;

    constructor(data?: IExpencePlaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ExpencePlaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExpencePlaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IExpencePlaceRequest {
    name?: string | undefined;
}

export class ExpencePlaceResponse implements IExpencePlaceResponse {
    id?: number;
    name?: string | undefined;

    constructor(data?: IExpencePlaceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ExpencePlaceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExpencePlaceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IExpencePlaceResponse {
    id?: number;
    name?: string | undefined;
}

export class ExpenceRequest implements IExpenceRequest {
    productId?: number;
    orderId?: number;
    price?: number;
    qantity?: number;
    amount?: number;
    discount?: number;

    constructor(data?: IExpenceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.orderId = _data["orderId"];
            this.price = _data["price"];
            this.qantity = _data["qantity"];
            this.amount = _data["amount"];
            this.discount = _data["discount"];
        }
    }

    static fromJS(data: any): ExpenceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["orderId"] = this.orderId;
        data["price"] = this.price;
        data["qantity"] = this.qantity;
        data["amount"] = this.amount;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IExpenceRequest {
    productId?: number;
    orderId?: number;
    price?: number;
    qantity?: number;
    amount?: number;
    discount?: number;
}

export class ExpenceResponse implements IExpenceResponse {
    id?: number;
    productName?: string | undefined;
    price?: number;
    qantity?: number;
    amount?: number;
    discount?: number;
    createdDate?: Date;

    constructor(data?: IExpenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.price = _data["price"];
            this.qantity = _data["qantity"];
            this.amount = _data["amount"];
            this.discount = _data["discount"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["price"] = this.price;
        data["qantity"] = this.qantity;
        data["amount"] = this.amount;
        data["discount"] = this.discount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IExpenceResponse {
    id?: number;
    productName?: string | undefined;
    price?: number;
    qantity?: number;
    amount?: number;
    discount?: number;
    createdDate?: Date;
}

export class OrderRequest implements IOrderRequest {
    expencePlaceId?: number;
    total?: number;
    totalDiscount?: number | undefined;
    userId?: number;
    paymentDate?: Date;
    isAutomatedPayment?: boolean;
    receiptImage?: string | undefined;

    constructor(data?: IOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expencePlaceId = _data["expencePlaceId"];
            this.total = _data["total"];
            this.totalDiscount = _data["totalDiscount"];
            this.userId = _data["userId"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.isAutomatedPayment = _data["isAutomatedPayment"];
            this.receiptImage = _data["receiptImage"];
        }
    }

    static fromJS(data: any): OrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expencePlaceId"] = this.expencePlaceId;
        data["total"] = this.total;
        data["totalDiscount"] = this.totalDiscount;
        data["userId"] = this.userId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["isAutomatedPayment"] = this.isAutomatedPayment;
        data["receiptImage"] = this.receiptImage;
        return data; 
    }
}

export interface IOrderRequest {
    expencePlaceId?: number;
    total?: number;
    totalDiscount?: number | undefined;
    userId?: number;
    paymentDate?: Date;
    isAutomatedPayment?: boolean;
    receiptImage?: string | undefined;
}

export class OrderResponse implements IOrderResponse {
    id?: number;
    expencePlace?: ExpencePlaceResponse;
    total?: number;
    totalDiscount?: number | undefined;
    user?: UserResponse;
    paymentDate?: Date;
    isAutomatedPayment?: boolean;
    receiptImage?: string | undefined;
    createdDate?: Date;
    expence?: ExpenceResponse[] | undefined;

    constructor(data?: IOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expencePlace = _data["expencePlace"] ? ExpencePlaceResponse.fromJS(_data["expencePlace"]) : <any>undefined;
            this.total = _data["total"];
            this.totalDiscount = _data["totalDiscount"];
            this.user = _data["user"] ? UserResponse.fromJS(_data["user"]) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.isAutomatedPayment = _data["isAutomatedPayment"];
            this.receiptImage = _data["receiptImage"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["expence"])) {
                this.expence = [] as any;
                for (let item of _data["expence"])
                    this.expence!.push(ExpenceResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expencePlace"] = this.expencePlace ? this.expencePlace.toJSON() : <any>undefined;
        data["total"] = this.total;
        data["totalDiscount"] = this.totalDiscount;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["isAutomatedPayment"] = this.isAutomatedPayment;
        data["receiptImage"] = this.receiptImage;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        if (Array.isArray(this.expence)) {
            data["expence"] = [];
            for (let item of this.expence)
                data["expence"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderResponse {
    id?: number;
    expencePlace?: ExpencePlaceResponse;
    total?: number;
    totalDiscount?: number | undefined;
    user?: UserResponse;
    paymentDate?: Date;
    isAutomatedPayment?: boolean;
    receiptImage?: string | undefined;
    createdDate?: Date;
    expence?: ExpenceResponse[] | undefined;
}

export class ProductRequest implements IProductRequest {
    name?: string | undefined;
    productTypeId?: number;

    constructor(data?: IProductRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.productTypeId = _data["productTypeId"];
        }
    }

    static fromJS(data: any): ProductRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["productTypeId"] = this.productTypeId;
        return data; 
    }
}

export interface IProductRequest {
    name?: string | undefined;
    productTypeId?: number;
}

export class ProductResponse implements IProductResponse {
    id?: number;
    name?: string | undefined;
    productTypeId?: number;

    constructor(data?: IProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productTypeId = _data["productTypeId"];
        }
    }

    static fromJS(data: any): ProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productTypeId"] = this.productTypeId;
        return data; 
    }
}

export interface IProductResponse {
    id?: number;
    name?: string | undefined;
    productTypeId?: number;
}

export class ProductTypeRequest implements IProductTypeRequest {
    name?: string | undefined;

    constructor(data?: IProductTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IProductTypeRequest {
    name?: string | undefined;
}

export class ProductTypeResponse implements IProductTypeResponse {
    id?: number;
    name?: string | undefined;

    constructor(data?: IProductTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProductTypeResponse {
    id?: number;
    name?: string | undefined;
}

export class SaveResponse implements ISaveResponse {
    typeName?: string | undefined;
    id?: number;
    saved?: boolean;

    constructor(data?: ISaveResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.id = _data["id"];
            this.saved = _data["saved"];
        }
    }

    static fromJS(data: any): SaveResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SaveResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["id"] = this.id;
        data["saved"] = this.saved;
        return data; 
    }
}

export interface ISaveResponse {
    typeName?: string | undefined;
    id?: number;
    saved?: boolean;
}

export class UserRequest implements IUserRequest {
    id?: number;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IUserRequest {
    id?: number;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
}

export class UserResponse implements IUserResponse {
    id?: number | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IUserResponse {
    id?: number | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}